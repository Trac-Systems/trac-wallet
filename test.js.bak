import PeerWallet from './index.js';
import * as bip39 from 'bip39';
import { bech32m } from 'bech32';
import sodium from 'sodium-native';
import { mnemonicToSeed } from 'bip39-mnemonic';
import b4a from 'b4a';
import slip10 from 'micro-key-producer/slip10.js';
import * as chai from 'chai';
import * as chaiAsPromised from 'chai-as-promised';
// import { fs } from './fs-provider.js';
import fs from 'fs';

const expect = chai.expect;
chai.use(chaiAsPromised.default || chaiAsPromised);

describe('Wallet', () => {
    let wallet;
    const validMnemonic = 'expire hobby crumble barely company behind solve kingdom plastic goddess congress sort awkward cancel ring quick gain wise doctor season fruit perfect fatal pool';

    beforeEach(() => {
        wallet = new PeerWallet();
        wallet.generateKeyPair(validMnemonic);
    });

    describe('HD Wallet Support', () => {
        it('should create a valid HD wallet from micro-key-producer based on peer wallet mnemonic, then HD wallet signs a message and is verified by both HD and PeerWallet.', async () => {
            const mnemonic = wallet.generateMnemonic();
            const walletLocal = new PeerWallet();
            await walletLocal.generateKeyPair(mnemonic);
            const seed = await mnemonicToSeed(mnemonic);
            const seed32 = await walletLocal.createHash('sha256', seed);

            const msg = 'this is a test';

            const hdkey = slip10.fromMasterSeed(seed32);
            const sig = hdkey.sign(b4a.toString(b4a.from(msg, 'utf8'), 'hex'));

            const hd_verify = hdkey.verify(b4a.toString(b4a.from(msg, 'utf8'), 'hex'), sig);
            const native_verify = walletLocal.verify(b4a.toString(sig, 'hex'), msg, b4a.toString(hdkey.publicKeyRaw, 'hex'));

            // reverse case tested through micro-key-producer hacking because it doesn't support off-wallet verify.
            // confirmed to work.
            /*
            const sig2 = walletLocal.sign(msg);
            const hd_verify2 = hdkey.verify2(b4a.toString(b4a.from(msg, 'utf8'), 'hex'), sig2, walletLocal.publicKey);
            console.log(hd_verify2)*/

            expect(hd_verify === native_verify).to.equal(true);
        });
    });

    describe('Mnemonic Generation', () => {
        it('should generate a valid mnemonic phrase', () => {
            const mnemonic = wallet.generateMnemonic();
            expect(mnemonic).to.be.a('string');
            expect(mnemonic.split(' ')).to.have.lengthOf(24);
            expect(bip39.validateMnemonic(mnemonic)).to.be.true;
        });

        it('should accept a valid mnemonic input', async () => {
            const walletLocal = new PeerWallet();
            await walletLocal.generateKeyPair(validMnemonic);
            expect(b4a.compare(walletLocal.publicKey, b4a.from('e7721fd6f77033521c3d89af96896db31f29579d33279f318bcdea4faa116aed', 'hex'))).to.equal(0);
        });

        it('should throw an error for mnemonic containing less than 24 words', async () => {
            const faultyMnemonic = 'expire hobby crumble barely company behind solve kingdom plastic goddess congress sort awkward cancel ring quick gain wise doctor season fruit perfect';
            const walletLocal = new PeerWallet();
            let thrown = false;
            try {
                // TODO: Update this test to use 'should.throw' syntax
                await walletLocal.generateKeyPair(faultyMnemonic);
            } catch (e) {
                thrown = true;
            }
            expect(thrown).to.equal(true);
        });

        it('should throw an error for mnemonic containing more than 24 words', async () => {
            const faultyMnemonic = 'expire hobby crumble barely company behind solve kingdom plastic goddess congress sort awkward cancel ring quick gain wise doctor season fruit perfect fatal pool pool';
            const walletLocal = new PeerWallet();
            let thrown = false;
            try {
                // TODO: Update this test to use 'should.throw' syntax
                await walletLocal.generateKeyPair(faultyMnemonic);
            } catch (e) {
                thrown = true;
            }
            expect(thrown).to.equal(true);
        });

        it('should throw an error for mnemonic containing invalid word', async () => {
            const faultyMnemonic = 'expire hobby crumble barely company behind solve kingdom plastic goddess congress sort awkward cancel ring quick gain wise doctor season fruit perfect fatal invalid';
            const walletLocal = new PeerWallet();
            let thrown = false;
            try {
                // TODO: Update this test to use 'should.throw' syntax
                await walletLocal.generateKeyPair(faultyMnemonic);
            } catch (e) {
                thrown = true;
            }
            expect(thrown).to.equal(true);
        });
    });

    describe('Key Pair Generation', () => {
        it('should generate a valid key pair and address', async () => {
            const networkPrefix = 'test';
            const walletLocal = new PeerWallet({ networkPrefix: networkPrefix });
            await walletLocal.generateKeyPair(validMnemonic);

            expect(b4a.isBuffer(walletLocal.publicKey)).to.be.true;
            expect(b4a.isBuffer(walletLocal.secretKey)).to.be.true;
            expect(typeof walletLocal.address).to.be.a('string');
            expect(walletLocal.publicKey).to.have.lengthOf(sodium.crypto_sign_PUBLICKEYBYTES);
            expect(walletLocal.secretKey).to.have.lengthOf(sodium.crypto_sign_SECRETKEYBYTES);
            expect(walletLocal.address.substring(0, networkPrefix.length + 1)).to.equal(networkPrefix + '1');
        });

        it('should not generate keys with empty input', () => {
            const emptyWallet = new PeerWallet();
            expect(emptyWallet.publicKey).to.be.null;
            expect(emptyWallet.secretKey).to.be.null;
            expect(emptyWallet.address).to.be.null;
        });

        it('should not generate keys with null input', () => {
            const options = {
                mnemonic: null
            };
            const emptyWallet = new PeerWallet(options);
            expect(emptyWallet.publicKey).to.be.null;
            expect(emptyWallet.secretKey).to.be.null;
            expect(emptyWallet.address).to.be.null;
        });

        it('should set a valid key pair', async () => {
            const wallet1 = new PeerWallet();
            await wallet1.generateKeyPair(validMnemonic);
            const wallet2 = new PeerWallet();
            const keyPair = {
                publicKey: "e7721fd6f77033521c3d89af96896db31f29579d33279f318bcdea4faa116aed",
                secretKey: "3b2383e03245c0b16cf223bbe80b5ce275557b15ce6b9754c60006a2eb04a169e7721fd6f77033521c3d89af96896db31f29579d33279f318bcdea4faa116aed"
            };
            wallet2.keyPair = keyPair;
            expect(b4a.equals(wallet2.publicKey, wallet1.publicKey)).to.be.true;
            expect(b4a.equals(wallet2.secretKey, wallet1.secretKey)).to.be.true;
            expect(wallet2.address).to.be.eq(wallet1.address);

            const message = 'Hello, world!';
            const sig1 = wallet1.sign(message);
            const sig2 = wallet2.sign(message);
            expect(b4a.equals(sig1, sig2)).to.be.true;
        });

        it('should throw an error for invalid key pair', () => {
            const newWallet = new PeerWallet();
            const invalidKeyPair = {
                publicKey: wallet.publicKey,
                secretKey: null
            };
            expect(() => newWallet.keyPair = invalidKeyPair).to.throw('Invalid key pair. Please provide a valid object with publicKey and secretKey');
        });
    });

    describe('Wallet bech32m encoding/decoding', () => {
        it('should encode a 32-byte public key buffer to a bech32m string and decode it back', () => {
            const publicKey = b4a.alloc(sodium.crypto_sign_PUBLICKEYBYTES);
            sodium.randombytes_buf(publicKey);

            const hrp = 'trac';
            const encoded = PeerWallet.encodeBech32m(publicKey, hrp);
            expect(encoded).to.be.a('string');
            expect(encoded.startsWith(hrp + '1')).to.be.true;

            const decoded = PeerWallet.decodeBech32m(encoded);
            expect(b4a.isBuffer(decoded)).to.be.true;
            expect(decoded.length).to.equal(sodium.crypto_sign_PUBLICKEYBYTES);
            expect(decoded.equals(publicKey)).to.be.true;
        });

        it('encoder should throw if input buffer has incorrect size', () => {
            const wrongBuffer = b4a.alloc(16);
            expect(() => PeerWallet.encodeBech32m(wrongBuffer, 'trac')).to.throw();
        });

        it('should throw if encoding input is not a buffer', () => {
            expect(() => PeerWallet.encodeBech32m('notabuffer', 'trac')).to.throw();
        });

        it('should throw for an invalid bech32m string', () => {
            expect(() => PeerWallet.decodeBech32m('invalidbech32mstring')).to.throw();
        });

        it('should return null for a bech32m string that decodes to wrong length', () => {
            const shortBuffer = b4a.alloc(16);
            sodium.randombytes_buf(shortBuffer);
            const hrp = 'trac';
            const encoded = bech32m.encode(hrp, bech32m.toWords(shortBuffer));
            expect(() => PeerWallet.decodeBech32m(encoded)).to.throw();
        });
    });

    describe('Wallet bech32m safe encoding/decoding', () => {
        it('should encode a 32-byte public key buffer to a bech32m string and decode it back', () => {
            const publicKey = b4a.alloc(sodium.crypto_sign_PUBLICKEYBYTES);
            sodium.randombytes_buf(publicKey);

            const hrp = 'trac';
            const encoded = PeerWallet.encodeBech32mSafe(publicKey, hrp);
            expect(encoded).to.be.a('string');
            expect(encoded.startsWith(hrp + '1')).to.be.true;

            const decoded = PeerWallet.decodeBech32mSafe(encoded);
            expect(b4a.isBuffer(decoded)).to.be.true;
            expect(decoded.length).to.equal(sodium.crypto_sign_PUBLICKEYBYTES);
            expect(decoded.equals(publicKey)).to.be.true;
        });

        it('encoder should return null if input buffer has incorrect size', () => {
            const wrongBuffer = b4a.alloc(16);
            const result = PeerWallet.encodeBech32mSafe(wrongBuffer, 'trac')
            expect(result).to.be.null;
        });

        it('should return null encoding input is not a buffer', () => {
            const result = PeerWallet.encodeBech32mSafe('notabuffer', 'trac')
            expect(result).to.be.null;
        });

        it('should return null for an invalid bech32m string', () => {
            const result = PeerWallet.decodeBech32mSafe('invalidbech32mstring')
            expect(result).to.be.null;
        });

        it('should return null for a bech32m string that decodes to wrong length', () => {
            const shortBuffer = b4a.alloc(16);
            sodium.randombytes_buf(shortBuffer);
            const hrp = 'trac';
            const encoded = bech32m.encode(hrp, bech32m.toWords(shortBuffer));
            const result = PeerWallet.decodeBech32mSafe(encoded)
            expect(result).to.be.null;
        });

    });

    describe('Message Signing and Verification', () => {
        it('should sign and verify a message signature', async () => {
            const message = 'Hello, world!';
            const wallet1 = new PeerWallet();
            await wallet1.generateKeyPair(validMnemonic);
            const signature = wallet1.sign(message);
            const isValid = PeerWallet.verify(signature, message, wallet1.publicKey);
            expect(isValid).to.be.true;
        });

        it('should sign and verify a message signature with external private key', () => {
            const message = 'Hello, world!';
            const keyPair = {
                publicKey: "82444d4f8f042ec06bbfba4f0b01043a5fdb03e8a8481d740b964563c0f91868",
                secretKey: "38ff0b5c840266901050964857c54b9f92836bc60383277a788084192ea5a2dc82444d4f8f042ec06bbfba4f0b01043a5fdb03e8a8481d740b964563c0f91868"
            };
            const signature = wallet.sign(Buffer.from(message), Buffer.from(keyPair.secretKey, 'hex'));
            const isValid = wallet.verify(signature, message, keyPair.publicKey);
            expect(isValid).to.be.true;
        });

        it('should sign and verify a message signature where secret key is external and validation arguments are a Buffer type', () => {
            const message = 'Hello, world!';
            const keyPair = {
                publicKey: "82444d4f8f042ec06bbfba4f0b01043a5fdb03e8a8481d740b964563c0f91868",
                secretKey: "38ff0b5c840266901050964857c54b9f92836bc60383277a788084192ea5a2dc82444d4f8f042ec06bbfba4f0b01043a5fdb03e8a8481d740b964563c0f91868"
            };
            const signature = wallet.sign(Buffer.from(message), Buffer.from(keyPair.secretKey, 'hex'));
            const isValid = wallet.verify(Buffer.from(signature, 'hex'), Buffer.from(message), Buffer.from(keyPair.publicKey, 'hex'));
            expect(isValid).to.be.true;
        });

        it('should verify a signature even with empty key pair', async () => {
            const emptyWallet = new PeerWallet();
            const wallet1 = new PeerWallet();
            await wallet1.generateKeyPair(validMnemonic);
            const message = 'Hello, world!';
            const signature = wallet1.sign(message);
            const isValid = emptyWallet.verify(signature, message, wallet1.publicKey);
            expect(isValid).to.be.true;
        });

        it('should not sign message when no keys are set', () => {
            const emptyWallet = new PeerWallet();
            expect(() => emptyWallet.sign('Hello, world!')).to.throw('No key pair found. Please, generate a key pair first');
        });
    });

    describe('Encryption and Decryption', () => {
        const data = JSON.stringify({ test: 'data' });

        it('should encrypt and decrypt data correctly', () => {
            const encryptionKey = b4a.alloc(32).fill('testingKey123!"§');
            const encryptedData = wallet.encrypt(b4a.from(data, 'utf8'), encryptionKey);
            const decryptedData = wallet.decrypt(encryptedData, encryptionKey);
            expect(JSON.stringify(decryptedData)).to.equal(data);
        });

        it('should throw an error if the decryption key is incorrect', () => {
            const rightKey = b4a.alloc(32).fill('rightKey123!"§');
            const wrongKey = b4a.alloc(32).fill('wrongKey123!"§');
            const encryptedData = wallet.encrypt(b4a.from(data, 'utf8'), rightKey);
            expect(() => wallet.decrypt(encryptedData, wrongKey)).to.throw('Failed to decrypt data. Invalid key or corrupted data.');
        });

        it('should throw an error if the encryption key is invalid', () => {
            const invalidKey = b4a.alloc(16).fill('invalidKey123!"§'); // Invalid key length
            expect(() => wallet.encrypt(b4a.from(data, 'utf8'), invalidKey)).to.throw(`Key must be a ${sodium.crypto_secretbox_KEYBYTES} bytes long buffer`);
        });

        it('should throw an error if the decryption key is invalid', () => {
            const encryptionKey = b4a.alloc(32).fill('rightKey123!"§');
            const invalidKey = b4a.alloc(16).fill('wrongKey123!"§'); // Invalid key length
            const encryptedData = wallet.encrypt(b4a.from(data, 'utf8'), encryptionKey);
            expect(() => wallet.decrypt(encryptedData, invalidKey)).to.throw(`Key must be ${sodium.crypto_secretbox_KEYBYTES} bytes long`);
        });
    });

    describe('Exporting Keys', () => {
        // TODO: In the future, this test will need to change, as it will NOT be possible to export a non-encrypted file anymore
        it('should export keys to a file - no encryption', async () => {
            const filePath = './wallet.json';
            const wallet1 = new PeerWallet();
            await wallet1.generateKeyPair(validMnemonic);
            await wallet1.exportToFile(filePath, validMnemonic);
            const data = JSON.parse(fs.readFileSync(filePath, 'utf8'));
            expect(data.salt).to.be.undefined;
            expect(data.nonce).to.be.undefined;
            expect(data.ciphertext).to.be.undefined;
            expect(data.publicKey).to.not.be.undefined;
            expect(data.secretKey).to.not.be.undefined;
            expect(data.mnemonic).to.not.be.undefined;
            fs.unlinkSync(filePath); // Clean up the file after test
        });

        // TODO: In the future, this test will need to change, as it will NOT be possible to import a non-encrypted file anymore
        it('should be able to import keys from a file - no encryption', async () => {
            const filePath = './wallet.json';
            const wallet1 = new PeerWallet();
            await wallet1.generateKeyPair(validMnemonic);
            await wallet1.exportToFile(filePath);
            const newWallet = new PeerWallet();
            await newWallet.importFromFile(filePath);
            expect(newWallet.publicKey.toString()).to.equal(wallet1.publicKey.toString());

            const message = 'Hello, world!';
            const sig1 = wallet1.sign(message);
            const sig2 = newWallet.sign(message);
            expect(b4a.compare(sig1, sig2)).to.equal(0);

            fs.unlinkSync(filePath); // Clean up the file after test
        });

        it('should correctly export and import a key file - with encryption', async () => {
            const filePath = './wallet.json';
            const encryptionKey = b4a.alloc(32).fill('someEncryptionKey');

            const wallet1 = new PeerWallet();
            await wallet1.generateKeyPair(validMnemonic);

            // Test exporting with encryption
            await wallet1.exportToFile(filePath, null, encryptionKey);
            const data = JSON.parse(fs.readFileSync(filePath, 'utf8'));
            expect(data.nonce).to.not.be.undefined;
            expect(data.ciphertext).to.not.be.undefined;
            expect(data.salt).to.not.be.undefined;
            expect(data.publicKey).to.be.undefined;
            expect(data.secretKey).to.be.undefined;
            expect(data.mnemonic).to.be.undefined;

            // Test importing with decryption
            const wallet2 = new PeerWallet();
            await wallet2.importFromFile(filePath, encryptionKey);
            expect(b4a.compare(wallet2.publicKey, wallet1.publicKey)).to.equal(0);

            // Test signing and verifying a message
            const message = 'Hello, world!';
            const sig1 = wallet1.sign(message);
            const sig2 = wallet2.sign(message);
            expect(b4a.compare(sig1, sig2)).to.equal(0);

            fs.unlinkSync(filePath); // Clean up the file after test
        });

        it('should not export keypair when no keys are set', async () => {
            const emptyWallet = new PeerWallet();
            await expect(emptyWallet.exportToFile('./wallet.json')).to.be.rejectedWith('No key pair found');
        });
    });
});

describe('Nonce Generation', () => {
    it('should return a buffer of 32 bytes', () => {
        const nonce = PeerWallet.generateNonce();
        expect(b4a.isBuffer(nonce)).to.be.true;
        expect(nonce.length).to.equal(32);
    });

    it('should return a different nonce each time', () => {
        const nonce1 = PeerWallet.generateNonce();
        const nonce2 = PeerWallet.generateNonce();
        expect(b4a.equals(nonce1, nonce2)).to.be.false;
    });

});